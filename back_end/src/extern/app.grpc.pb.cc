// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: app.proto

#include "app.pb.h"
#include "app.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace app {

static const char* RPCRoute_method_names[] = {
  "/app.RPCRoute/SignUp",
  "/app.RPCRoute/Login",
  "/app.RPCRoute/AllQuestions",
  "/app.RPCRoute/MyQuestions",
  "/app.RPCRoute/AskQuestion",
  "/app.RPCRoute/AnswerQuestion",
};

std::unique_ptr< RPCRoute::Stub> RPCRoute::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< RPCRoute::Stub> stub(new RPCRoute::Stub(channel, options));
  return stub;
}

RPCRoute::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_SignUp_(RPCRoute_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Login_(RPCRoute_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_AllQuestions_(RPCRoute_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_MyQuestions_(RPCRoute_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_AskQuestion_(RPCRoute_method_names[4], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_AnswerQuestion_(RPCRoute_method_names[5], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status RPCRoute::Stub::SignUp(::grpc::ClientContext* context, const ::app::User& request, ::app::IsOK* response) {
  return ::grpc::internal::BlockingUnaryCall< ::app::User, ::app::IsOK, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SignUp_, context, request, response);
}

void RPCRoute::Stub::async::SignUp(::grpc::ClientContext* context, const ::app::User* request, ::app::IsOK* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::app::User, ::app::IsOK, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SignUp_, context, request, response, std::move(f));
}

void RPCRoute::Stub::async::SignUp(::grpc::ClientContext* context, const ::app::User* request, ::app::IsOK* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SignUp_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::app::IsOK>* RPCRoute::Stub::PrepareAsyncSignUpRaw(::grpc::ClientContext* context, const ::app::User& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::app::IsOK, ::app::User, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SignUp_, context, request);
}

::grpc::ClientAsyncResponseReader< ::app::IsOK>* RPCRoute::Stub::AsyncSignUpRaw(::grpc::ClientContext* context, const ::app::User& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSignUpRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status RPCRoute::Stub::Login(::grpc::ClientContext* context, const ::app::User& request, ::app::IsOK* response) {
  return ::grpc::internal::BlockingUnaryCall< ::app::User, ::app::IsOK, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Login_, context, request, response);
}

void RPCRoute::Stub::async::Login(::grpc::ClientContext* context, const ::app::User* request, ::app::IsOK* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::app::User, ::app::IsOK, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Login_, context, request, response, std::move(f));
}

void RPCRoute::Stub::async::Login(::grpc::ClientContext* context, const ::app::User* request, ::app::IsOK* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Login_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::app::IsOK>* RPCRoute::Stub::PrepareAsyncLoginRaw(::grpc::ClientContext* context, const ::app::User& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::app::IsOK, ::app::User, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Login_, context, request);
}

::grpc::ClientAsyncResponseReader< ::app::IsOK>* RPCRoute::Stub::AsyncLoginRaw(::grpc::ClientContext* context, const ::app::User& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncLoginRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status RPCRoute::Stub::AllQuestions(::grpc::ClientContext* context, const ::app::RequestQuestions& request, ::app::Questions* response) {
  return ::grpc::internal::BlockingUnaryCall< ::app::RequestQuestions, ::app::Questions, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_AllQuestions_, context, request, response);
}

void RPCRoute::Stub::async::AllQuestions(::grpc::ClientContext* context, const ::app::RequestQuestions* request, ::app::Questions* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::app::RequestQuestions, ::app::Questions, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AllQuestions_, context, request, response, std::move(f));
}

void RPCRoute::Stub::async::AllQuestions(::grpc::ClientContext* context, const ::app::RequestQuestions* request, ::app::Questions* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AllQuestions_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::app::Questions>* RPCRoute::Stub::PrepareAsyncAllQuestionsRaw(::grpc::ClientContext* context, const ::app::RequestQuestions& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::app::Questions, ::app::RequestQuestions, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_AllQuestions_, context, request);
}

::grpc::ClientAsyncResponseReader< ::app::Questions>* RPCRoute::Stub::AsyncAllQuestionsRaw(::grpc::ClientContext* context, const ::app::RequestQuestions& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncAllQuestionsRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status RPCRoute::Stub::MyQuestions(::grpc::ClientContext* context, const ::app::RequestQuestions& request, ::app::Questions* response) {
  return ::grpc::internal::BlockingUnaryCall< ::app::RequestQuestions, ::app::Questions, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_MyQuestions_, context, request, response);
}

void RPCRoute::Stub::async::MyQuestions(::grpc::ClientContext* context, const ::app::RequestQuestions* request, ::app::Questions* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::app::RequestQuestions, ::app::Questions, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MyQuestions_, context, request, response, std::move(f));
}

void RPCRoute::Stub::async::MyQuestions(::grpc::ClientContext* context, const ::app::RequestQuestions* request, ::app::Questions* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_MyQuestions_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::app::Questions>* RPCRoute::Stub::PrepareAsyncMyQuestionsRaw(::grpc::ClientContext* context, const ::app::RequestQuestions& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::app::Questions, ::app::RequestQuestions, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_MyQuestions_, context, request);
}

::grpc::ClientAsyncResponseReader< ::app::Questions>* RPCRoute::Stub::AsyncMyQuestionsRaw(::grpc::ClientContext* context, const ::app::RequestQuestions& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncMyQuestionsRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status RPCRoute::Stub::AskQuestion(::grpc::ClientContext* context, const ::app::Question& request, ::app::IsOK* response) {
  return ::grpc::internal::BlockingUnaryCall< ::app::Question, ::app::IsOK, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_AskQuestion_, context, request, response);
}

void RPCRoute::Stub::async::AskQuestion(::grpc::ClientContext* context, const ::app::Question* request, ::app::IsOK* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::app::Question, ::app::IsOK, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AskQuestion_, context, request, response, std::move(f));
}

void RPCRoute::Stub::async::AskQuestion(::grpc::ClientContext* context, const ::app::Question* request, ::app::IsOK* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AskQuestion_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::app::IsOK>* RPCRoute::Stub::PrepareAsyncAskQuestionRaw(::grpc::ClientContext* context, const ::app::Question& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::app::IsOK, ::app::Question, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_AskQuestion_, context, request);
}

::grpc::ClientAsyncResponseReader< ::app::IsOK>* RPCRoute::Stub::AsyncAskQuestionRaw(::grpc::ClientContext* context, const ::app::Question& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncAskQuestionRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status RPCRoute::Stub::AnswerQuestion(::grpc::ClientContext* context, const ::app::Question& request, ::app::IsOK* response) {
  return ::grpc::internal::BlockingUnaryCall< ::app::Question, ::app::IsOK, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_AnswerQuestion_, context, request, response);
}

void RPCRoute::Stub::async::AnswerQuestion(::grpc::ClientContext* context, const ::app::Question* request, ::app::IsOK* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::app::Question, ::app::IsOK, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AnswerQuestion_, context, request, response, std::move(f));
}

void RPCRoute::Stub::async::AnswerQuestion(::grpc::ClientContext* context, const ::app::Question* request, ::app::IsOK* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AnswerQuestion_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::app::IsOK>* RPCRoute::Stub::PrepareAsyncAnswerQuestionRaw(::grpc::ClientContext* context, const ::app::Question& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::app::IsOK, ::app::Question, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_AnswerQuestion_, context, request);
}

::grpc::ClientAsyncResponseReader< ::app::IsOK>* RPCRoute::Stub::AsyncAnswerQuestionRaw(::grpc::ClientContext* context, const ::app::Question& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncAnswerQuestionRaw(context, request, cq);
  result->StartCall();
  return result;
}

RPCRoute::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RPCRoute_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RPCRoute::Service, ::app::User, ::app::IsOK, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RPCRoute::Service* service,
             ::grpc::ServerContext* ctx,
             const ::app::User* req,
             ::app::IsOK* resp) {
               return service->SignUp(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RPCRoute_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RPCRoute::Service, ::app::User, ::app::IsOK, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RPCRoute::Service* service,
             ::grpc::ServerContext* ctx,
             const ::app::User* req,
             ::app::IsOK* resp) {
               return service->Login(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RPCRoute_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RPCRoute::Service, ::app::RequestQuestions, ::app::Questions, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RPCRoute::Service* service,
             ::grpc::ServerContext* ctx,
             const ::app::RequestQuestions* req,
             ::app::Questions* resp) {
               return service->AllQuestions(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RPCRoute_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RPCRoute::Service, ::app::RequestQuestions, ::app::Questions, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RPCRoute::Service* service,
             ::grpc::ServerContext* ctx,
             const ::app::RequestQuestions* req,
             ::app::Questions* resp) {
               return service->MyQuestions(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RPCRoute_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RPCRoute::Service, ::app::Question, ::app::IsOK, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RPCRoute::Service* service,
             ::grpc::ServerContext* ctx,
             const ::app::Question* req,
             ::app::IsOK* resp) {
               return service->AskQuestion(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RPCRoute_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RPCRoute::Service, ::app::Question, ::app::IsOK, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RPCRoute::Service* service,
             ::grpc::ServerContext* ctx,
             const ::app::Question* req,
             ::app::IsOK* resp) {
               return service->AnswerQuestion(ctx, req, resp);
             }, this)));
}

RPCRoute::Service::~Service() {
}

::grpc::Status RPCRoute::Service::SignUp(::grpc::ServerContext* context, const ::app::User* request, ::app::IsOK* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status RPCRoute::Service::Login(::grpc::ServerContext* context, const ::app::User* request, ::app::IsOK* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status RPCRoute::Service::AllQuestions(::grpc::ServerContext* context, const ::app::RequestQuestions* request, ::app::Questions* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status RPCRoute::Service::MyQuestions(::grpc::ServerContext* context, const ::app::RequestQuestions* request, ::app::Questions* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status RPCRoute::Service::AskQuestion(::grpc::ServerContext* context, const ::app::Question* request, ::app::IsOK* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status RPCRoute::Service::AnswerQuestion(::grpc::ServerContext* context, const ::app::Question* request, ::app::IsOK* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace app

